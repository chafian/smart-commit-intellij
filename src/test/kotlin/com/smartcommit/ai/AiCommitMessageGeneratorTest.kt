package com.smartcommit.ai

import com.smartcommit.diff.model.*
import com.smartcommit.generator.CommitMessageGenerator
import com.smartcommit.generator.model.GeneratedCommitMessage
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import org.junit.Assert.*
import org.junit.Test

/**
 * Unit tests for [AiCommitMessageGenerator].
 * Uses MockK for [AiProvider] and fallback [CommitMessageGenerator].
 * No network, no IntelliJ APIs.
 */
class AiCommitMessageGeneratorTest {

    // ── Helpers ──────────────────────────────────────────────

    private fun fileDiff(path: String, type: ChangeType = ChangeType.MODIFIED) = FileDiff(
        filePath = path, oldFilePath = null, changeType = type,
        fileExtension = path.substringAfterLast('.', ""),
        diff = "+changed", linesAdded = 1, linesDeleted = 0, isBinary = false
    )

    private val testSummary = DiffSummary(
        fileDiffs = listOf(fileDiff("src/main/Foo.kt")),
        classifications = mapOf(fileDiff("src/main/Foo.kt") to ChangeCategory.FEATURE)
    )

    private val emptySummary = DiffSummary(emptyList(), emptyMap())

    private val fallbackMessage = GeneratedCommitMessage(
        title = "fallback: Update Foo.kt",
        body = "Generated by template"
    )

    private fun mockProvider(response: Result<String>): AiProvider {
        val provider = mockk<AiProvider>()
        every { provider.name } returns "MockAI"
        every { provider.complete(any(), any()) } returns response
        return provider
    }

    private fun mockFallback(): CommitMessageGenerator {
        val fb = mockk<CommitMessageGenerator>()
        every { fb.displayName } returns "Template"
        every { fb.generate(any()) } returns fallbackMessage
        return fb
    }

    private fun generator(
        provider: AiProvider,
        fallback: CommitMessageGenerator = mockFallback()
    ): AiCommitMessageGenerator {
        return AiCommitMessageGenerator(
            provider = provider,
            promptBuilder = PromptBuilder(),
            fallback = fallback
        )
    }

    // ── Successful AI generation ────────────────────────────

    @Test
    fun `generate returns AI message on valid JSON response`() {
        val aiJson = """{"title": "Add authentication flow", "body": "Implement JWT login"}"""
        val gen = generator(mockProvider(Result.success(aiJson)))

        val result = gen.generate(testSummary)
        assertEquals("Add authentication flow", result.title)
        assertEquals("Implement JWT login", result.body)
    }

    @Test
    fun `generate returns AI message with title only`() {
        val aiJson = """{"title": "Fix null pointer"}"""
        val gen = generator(mockProvider(Result.success(aiJson)))

        val result = gen.generate(testSummary)
        assertEquals("Fix null pointer", result.title)
        assertNull(result.body)
    }

    @Test
    fun `generate truncates long AI title to 72 chars`() {
        val longTitle = "A".repeat(100)
        val aiJson = """{"title": "$longTitle"}"""
        val gen = generator(mockProvider(Result.success(aiJson)))

        val result = gen.generate(testSummary)
        assertTrue(result.title.length <= 72)
    }

    @Test
    fun `generate handles AI response with footer`() {
        val aiJson = """{"title": "Fix bug", "body": "details", "footer": "Closes #99"}"""
        val gen = generator(mockProvider(Result.success(aiJson)))

        val result = gen.generate(testSummary)
        assertEquals("Closes #99", result.footer)
    }

    // ── Fallback on provider error ──────────────────────────

    @Test
    fun `generate falls back when provider returns failure`() {
        val fb = mockFallback()
        val gen = generator(
            mockProvider(Result.failure(RuntimeException("Network error"))),
            fallback = fb
        )

        val result = gen.generate(testSummary)
        assertEquals(fallbackMessage.title, result.title)
        verify(exactly = 1) { fb.generate(testSummary) }
    }

    @Test
    fun `generate falls back when provider returns empty string`() {
        val fb = mockFallback()
        val gen = generator(mockProvider(Result.success("")), fallback = fb)

        val result = gen.generate(testSummary)
        assertEquals(fallbackMessage.title, result.title)
        verify(exactly = 1) { fb.generate(testSummary) }
    }

    @Test
    fun `generate falls back when provider returns blank string`() {
        val fb = mockFallback()
        val gen = generator(mockProvider(Result.success("   ")), fallback = fb)

        val result = gen.generate(testSummary)
        assertEquals(fallbackMessage.title, result.title)
    }

    // ── Fallback on parse error ─────────────────────────────

    @Test
    fun `generate falls back on completely unparseable response`() {
        // Empty lines after trim → parse returns failure
        val fb = mockFallback()
        val gen = generator(mockProvider(Result.success("\n\n\n")), fallback = fb)

        val result = gen.generate(testSummary)
        assertEquals(fallbackMessage.title, result.title)
    }

    // ── Fallback on malformed JSON ──────────────────────────

    @Test
    fun `generate handles JSON with missing title by using free-text fallback`() {
        // AiResponse will attempt parseFallback on the raw text
        val raw = """{"body": "no title here"}"""
        val gen = generator(mockProvider(Result.success(raw)))

        // parseFallback will extract the first line as title
        val result = gen.generate(testSummary)
        // Should succeed — either via JSON fallback or free-text extraction
        assertTrue(result.title.isNotBlank())
    }

    @Test
    fun `generate handles AI response wrapped in markdown fences`() {
        val raw = """
            Here is your commit message:
            ```json
            {"title": "Refactor auth module", "body": "Extract shared logic"}
            ```
        """.trimIndent()
        val gen = generator(mockProvider(Result.success(raw)))

        val result = gen.generate(testSummary)
        assertEquals("Refactor auth module", result.title)
        assertEquals("Extract shared logic", result.body)
    }

    @Test
    fun `generate handles AI response as plain text`() {
        val raw = "Add user authentication\nImplement JWT-based login flow"
        val gen = generator(mockProvider(Result.success(raw)))

        val result = gen.generate(testSummary)
        assertEquals("Add user authentication", result.title)
        assertEquals("Implement JWT-based login flow", result.body)
    }

    // ── Empty changeset ─────────────────────────────────────

    @Test
    fun `generate returns fallback on empty summary`() {
        // AiCommitMessageGenerator contract: NEVER throws. Returns safe fallback.
        val gen = generator(mockProvider(Result.success("{}")))
        val result = gen.generate(emptySummary)
        assertEquals("Update code", result.title)
    }

    // ── Provider is called with correct prompts ─────────────

    @Test
    fun `generate passes system and user prompts to provider`() {
        val provider = mockk<AiProvider>()
        every { provider.name } returns "Mock"
        every { provider.complete(any(), any()) } returns Result.success("""{"title": "Test"}""")

        val gen = AiCommitMessageGenerator(provider = provider, promptBuilder = PromptBuilder())
        gen.generate(testSummary)

        verify {
            provider.complete(
                match { it.contains("commit message generator") },
                match { it.contains("src/main/Foo.kt") }
            )
        }
    }

    // ── Metadata ────────────────────────────────────────────

    @Test
    fun `displayName includes provider name`() {
        val gen = generator(mockProvider(Result.success("{}")))
        assertEquals("AI (MockAI)", gen.displayName)
    }
}
